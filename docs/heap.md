# heap collection

## [215.数组中的第K个最大元素](../src/215.数组中的第k个最大元素_2.java)

堆排序。

- 时间复杂度：$O(n\log n)$，建堆的时间代价是 $O(n)$，删除的总代价是 $O(k\log n)$，因为 $k < n$，故渐进时间复杂为 $O(n+k\log n) = O(n\log n)$。

- 空间复杂度：$O(1)$。

## [264.丑数-ii](../src/264.丑数-ii_1.java)

## [295.数据流的中位数](../src/295.数据流的中位数_1.java)

小于等于上一次中位数的数放在大根堆，否则放在小根堆。

## [313.超级丑数](../src/313.超级丑数_1.java)

## [373.查找和最小的 K 对数字](../src/373.查找和最小的-k-对数字_1.java)

若第 $n$ 对为 $(nums1[i],nums2[j])$，则第 $n+1$ 对可能为 $(nums1[0],nums2[j+1])$，$(nums1[1],nums2[j+1])$，$\cdots$，$(nums1[i],nums2[j+1])$ 或 $(nums1[i+1],nums2[0])$，$(nums1[i+1],nums2[1])$，$\cdots$，$(nums1[i+1],nums2[j])$。

利用小顶堆，每次取出堆顶元素 $(nums1[i],nums2[j])$，并将 $(nums1[i+1],nums2[j])$，$(nums1[i],nums2[j+1])$ 加入堆中。由于可能产生重复，通过提前放入 $[0,k]$ 的 $nums1$ 元素，后面只增加 $nums2$ 元素索引从而避免重复。

- 时间复杂度：$O(k\log k)$。

- 空间复杂度：$O(k)$。

## [502.IPO](../src/502.ipo.java)

`贪心` + `堆`。

## [703.数据流中的第 K 大元素](../src/703.数据流中的第-k-大元素.java)

## 2336.无限集中的最小数字

1. [记录所有数](../src/2336.无限集中的最小数字_1.java)

2. [分为连续、非连续部分，堆保存非连续部分](../src/2336.无限集中的最小数字.java)

## [2462.雇佣 K 位工人的总代价](../src/2462.雇佣-k-位工人的总代价.java)

`双堆`。

## [2542.最大子序列的分数](../src/2542.最大子序列的分数.java)

`排序` + `堆`。

## [面试题 17.14. 最小K个数](../cn/Java/_____17_14_Smallest_K_LCCI_1/Solution.java)

## [面试题 17.20. 连续中值](../cn/Java/_____17_20_Continuous_Median_LCCI/Solution.java)
