# queue collection

## [387.字符串中的第一个唯一字符](../src/387.字符串中的第一个唯一字符.java)

哈希表 + 队列。

## 649.Dota2 参议院

1. [单队列](../src/649.dota-2-参议院_1.java)

2. [双队列](../src/649.dota-2-参议院.java)

## [933.最近的请求次数](../src/933.最近的请求次数.java)

## [1466.重新规划路线](../src/1466.重新规划路线.java)

可将节点两个部分：

1. 第一部分**保证节点到达** $0$ 节点。

2. 第二部分**不能保证到达** $0$ 节点。

使用队列 $Q$ 保存当前状态下**可能连接有第二部分的第一部分节点**，需要更改路径的次数设为 $k$。

考虑下图：

<img alt="graph example" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_1_1819.png" width="300"/>

初始状态下，$Q=\{0\}，k=0$。

进行以下操作：

1. 取出队头节点 $0$，对 $0$ 节点进行深搜：分别来到节点 $1、3$，说明 $1、3$ 节点的路径**不能到达 $0$ 节点**，此时需要把路径反向的次数为 $2$。

2. 对于搜索过程中每条路径的节点，由于指向该节点的节点 $i$ 是肯定能到达 $0$ 节点（$i$ 属于第一部分），但不能保证 **$i$ 节点连接的其它未被访问的节点 $j$** 能够到达 $0$（$j$ 属于第二部分），故将 **$i$ 节点** 入队（$i$ 是可能连接有第二部分的第一部分节点）。

此时 $Q=\{2,4\}，k=2$。

继续执行以上操作：$Q=\{\}，k=3$。

此时队列为空，需要更改路径的次数为 $k=3$。

- 时间复杂度：$O(n)$，其中 $n$ 为节点的数量。每个节点最多入队一次，深搜时最多被扩展一次。

- 空间复杂度：$O(n)$，其中 $n$ 为节点的数量。队列和深搜栈空间不会超过 $n$。

## [面试题 03.06. 动物收容所](../cn/Java/_____03_06_Animal_Shelter_LCCI/Solution.java)

## [面试题 08.04. 幂集](../cn/Java/_____08_04_Power_Set_LCCI_1/Solution.java)
